# API Reference

For specifics on the exact types of these components/functions/values, please check the implementation. Autogenerated documentation is forthcoming, once [TypeDoc supports Typescript 1.8](https://github.com/TypeStrong/typedoc/issues/210).

## Core

### `Stack`

`Stack`s are the basic unit of layout. Any direct children will be automatically styled and sized to overlay on one another, stacking in the Z direction and matching in vertical/horizontal dimensions. `Stack`s may be freely nested.

#### Props

- `className?`: space-separated DOM class names to be merged with the default class names.
- `pixelRatio?`: the desired pixel density of this chart. See [`window.devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio). Performance may suffer with higher values. This value is not transparently applied and must be explicitly respected by any contained `Layer`s (the built-in ones all do).

<hr/>

### `ChartProvider`

`ChartProvider` is the parent of all state-managed layers in react-layered-chart. It creates almost no DOM of its own, but is instead a wrapper around react-redux's [`Provider`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store) that mediates between its own props and state that is automatically loaded/computed.

#### Props

- `seriesIds`: a list of all the series that are present in this chart. IDs are arbitrary and must be unique within a single `ChartProvider`. Series IDs not present here will be silently ignored.
- `loadData`: a stateless function to load the appropriate data for all series. Called whenever `ChartProvider` needs new data. This is where you should do caching or other loading optimizations.
- `className?`: space-separated DOM class names to be merged with the default class names.
- `pixelRatio?`: the desired pixel density of this chart. See [`window.devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio). Performance may suffer with higher values. This value is not transparently applied and must be explicitly respected by any contained `Layer`s (the built-in ones all do). If specified here, you do not need to specify this value on any contained `Stack`s.
- `chartId?`: an arbitrary, globally-unique ID for the state of this chart that maintains a reference across mount/unmount cycles.
- `defaultState?`: UI state to seed the internal store with. This value is only respected once, at initialization time.
- `onLoadStateChange?`: called with the load states of all series whenever any one of them changes.
- `onError?`: called with the error state of all series whenever any one of them changes.
- `includeResizeSentinel?`: if `false`, prevents the automatic addition of a `ConnectedResizeSentinelLayer`. Use this option if you have layouts or styles that cause the included sentinel layer to incorrectly report the physical chart size. Be sure to replace it with your own `ConnectedResizeSentinelLayer`, otherwise your chart won't render with the correct dimensions!

#### Controlled Props

These props come in read-write pairs and implement the ["controlled component" pattern](https://facebook.github.io/react/docs/forms.html#controlled-components). The "value" props unconditionally trump any automatically-computed values. The "on change" props are called any time the automatically-computed values change to give the parent a chance to incorporate those changes. You can provide any combination of these parameters; providing a "value" prop doesn't imply you need an "on change" prop, nor vice versa.

- `xDomain?`
- `onXDomainChange?`
- `yDomains?`
- `onYDomainsChange?`
- `selection?`
- `onSelectionChange?`
- `hover?`
- `onHoverChange?`

## Layers

To see some layers in action, check out the example page.

### Data Layers

These components render different types of visualizations for data. They all follow the same basic pattern of accepting props for:

- the data they are to render; usually, an array named `data`
- `xDomain`, which describes what horizontal domain they're currently covering so they can render the appropriate subset of data
- usually `yDomain`, which describes what vertical domain they're currently covering so they can render the data in the appropriate visual location

And some combination of `color`, `fill`, `stroke`, `font`, `yScale` or other display-related props.

The layers in this category are:

- `BarLayer`
- `BrushLayer`
- `BucketedLineLayer`
- `HoverLineLayer`
- `PointLayer`
- `SimpleLineLayer`
- `TimeSpanLayer`

Additionally, most of these layers have "connected" variants that replace the `xDomain`, `yDomain` and `data` (or analogous) props with a `seriesId` prop that specifies which data they should read. These layers must be inside a `ChartProvider` to work correctly:

- `ConnectedBarLayer`
- `ConnectedBrushLayer`
- `ConnectedBucketedLineLayer`
- `ConnectedHoverLineLayer`
- `ConnectedPointLayer`
- `ConnectedSimpleLineLayer`

<hr/>

### `XAxisLayer`

This component renders the X domain. By default, it interprets the numerical value as a timestamp, but you can specify a different scale and set of tick formats to change this behavior.

#### Props

- `xDomain`: the X domain to display on this layer.
- `scale?`: a [d3-scale](https://github.com/d3/d3-scale) constructor function. Only continuous scales are supported. Defaults to `scaleTime`.
- `ticks?`: an array, function or number describing where to place annotated tick marks. As an array, it specifies any values that should have ticks. As a function, it takes the domain and returns such an array. As a number, it is passed to `scale#ticks` for d3 to take a guess at what ticks are appropriate.
- `tickFormat?`: a string or function appropriate for passing as the second argument to d3's scales' [`tickFormat`](https://github.com/d3/d3-scale#continuous_tickFormat).
- `color?`: a hex string specifying the color to use for drawing.
- `font?`: a *fully-qualified* name of a font with size, such as `'12px MyriadPro-Regular'`. A font-family is not sufficient.

There is a `ConnectedXAxisLayer` that accepts the same props, except `xDomain`.

<hr/>

### `YAxisLayer`

This component renders one or more Y domains, lined up next to each other on the left side of the rendering area. Most props are arrays that are matched by index to the corresponding item in `yDomains`. These arrays can have `null`/`undefined` entries, which will fall back on the default value for that prop.

#### Props

- `yDomains`: an array of all the Y domains to render.
- `scales?`: an array of [d3-scale](https://github.com/d3/d3-scale) constructor functions. Only continuous scales are supported. Defaults to `scaleLinear`.
- `ticks?`: an array of arrays, functions or numbers describing where to place annotated tick marks. If an item is an array, it specifies any values that should have ticks. As a function, it takes the domain and returns such an array. As a number, it is passed to `scale#ticks` for d3 to take a guess at what ticks are appropriate.
- `tickFormat?`: an array of strings or functions appropriate for passing as the second argument to d3's scales' [`tickFormat`](https://github.com/d3/d3-scale#continuous_tickFormat).
- `colors?`: an array of hex strings specifying the colors to use for each axis when drawing.
- `font?`: a *fully-qualified* name of a font with size, such as `'12px MyriadPro-Regular'`. A font-family is not sufficient.
- `backgroundColor?`: a hex string specifying a color to draw behind the axis, which is useful since the Y axis often overlaps the data. Defaults to `rgba(255, 255, 255, 0.8)`.

`YAxisLayer` does not yet have a "connected" variant.

<hr/>

### `AutoresizingCanvasLayer`

A component that wraps and exposes a `<canvas>` that (via polling) matches the size of its containing `Stack`. This class does no rendering of its own, but provides a well-behaved blank canvas for a parent component to draw on. All built-in data-rendering layers are based on this component in combination with the `NonReactRender` decorator.

#### Props

- `onSizeChange()`: a function called with no arguments when the size changes, usually, some kind of render method.
- `className?`: space-separated DOM class names to be merged with the default class names.

#### Instance Methods

- `getCanvasElement()`: returns the `<canvas>` element for this layer.
- `getDimensions()`: returns the true `{ width, height }` of this layer.

#### Static Methods

- `resetCanvas(canvasLayer, pixelRatio?)`: clears and resizes the underlying `<canvas>` for the given `canvasLayer` in preparation for a rendering frame. Additionally, it translates the canvas by half a pixel to get crisper rendering behavior. Returns `{ width, height, context }`.

<hr/>

### `InteractionCaptureLayer`

This layer displays nothing, but captures all mouse events and translates them into callbacks or (in the case of the "connected" variant) fires actions.

#### Props

- `xDomain`: specifies the X domain this layer currently covers so it can translate mouse positions to logical values.
- `shouldZoom?(event)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event should be used for zooming.
- `shouldPan?(event)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event constitutes the beginning of a pan gesture.
- `shouldBrush?(event)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event constitutes the beginning of a brush (selection) gesture.
- `onZoom?(factor, anchorBias)`: fired when the user performs a legal zoom gesture. See `zoomRange` for an explanation of the parameters.
- `onPan?(logicalUnits)`: fired when the user moves their mouse during a legal pan gesture.
- `onBrush?(logicalUnitRange?)`: fired when the user moves their mouse during a legal brush gesture. Called with `null` if the selection is cleared.
- `onHover?(logicalPosition)`: fired when the user hovers over the chart.
- `zoomSpeed?`: a constant factor to adjust the sensitivity of the zooming gesture for different scroll velocities.

#### `ConnectedInteractionCaptureLayer` Props

This variant of the layer replaces the callbacks with simple `true`/`false` settings to enable different types of gestures. The interpreted results are automatically fired as actions on containing `ChartProvider`.

- `enablePan?`: whether or not to fire events for pan gestures. Default `false`.
- `enableZoom?`: whether or not to fire events for zoom gestures. Default `false`.
- `enableHover?`: whether or not to fire events for hover gestures. Default `false`.
- `enableBrush?`: whether or not to fire events for brush gestures. Default `false`.
- `shouldZoom?`: same as above.
- `shouldPan?`: same as above.
- `shouldBrush?`: same as above.
- `zoomSpeed?`: same as above.

<hr/>

### `ConnectedResizeSentinelLayer`

This layer accepts no props. It polls itself to determine its size, and fires and action on the containing `ChartProvider` whenever it changes. This value is used to determine what density to load data at. An instance of this layer is auto-injected into every `ChartProvider`; you shouldn't need to make your own unless styling or layout rules make the default placement of the layer compute incorrect values, which is rare. If you do define your own, note that you only need one instance.

## State Management

### `ChartProviderState`

An opaque type that represents all of the internal chart state. You should not read from this type directly, but instead use the provided selectors and action creators to read and write to it, respectively.

<hr/>

### Selectors

These [selectors](https://github.com/reactjs/reselect) take the entire `ChartProviderState` and return one facet of the state. Several of them are counterparts to the "controlled props" on `ChartProvider`.

- `selectXDomain(state)`
- `selectYDomains(state)`
- `selectHover(state)`
- `selectSelection(state)`
- `selectData(state)`
- `selectIsLoading(state)`
- `selectError(state)`
- `selectChartPixelWidth(state)`

You can use these in a [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options)ed component like so (assuming the component will be used inside a `ChartProvider`):

```tsx
import { connect } from 'react-redux';
import { selectXDomain, ChartProviderState } from 'react-layered-chart';

class ExampleComponent extends React.Component<...> {
  render() {
    console.log(this.props.xDomain);
  }
}

function mapStateToProps(state: ChartProviderState) {
  return {
    xDomain: selectXDomain(state)
  };
}

export default connect(mapStateToProps)(ExampleComponent);
```

<hr/>

### Action Creators

These action creators are analogous to some of the "controlled props" on `ChartProvider`. They are intended to be used with [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) and, optionally, [`bindActionCreators`](http://redux.js.org/docs/api/bindActionCreators.html).

- `setXDomain(domain)`
- `setYDomains(domains)`
- `setHover(hover)`
- `setSelection(selection)`

You can use these in a [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options)ed component like so (assuming the component will be used inside a `ChartProvider`):

```tsx
import { Dispatch, bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { setXDomain } from 'react-layered-chart';

class ExampleComponent extends React.Component<...> {
  render() {
    return <div onClick={() => this.props.setXDomain(...)}/>;
  }
}

function mapStateToProps(dispatch: Dispatch) {
  return bindActionCreators({ setXDomain }, dispatch);
}

export default connect(null, mapDispatchToProps)(ExampleComponent);
```

## Utilities

### Decorators

#### `AnimateProps`

A class decorator to animate prop values by repeatedly setting values on state for each frame. Specify the props to animate using an instance variable named `animatedProps`, which is a map from prop names to millisecond durations for their animations. Animated values will be set on component state any time the component updates using the pattern `` `animated_${propName}` ``. Interpolation is delegated to [d3-interpolate](https://github.com/d3/d3-interpolate).

You can access a mixin version at `AnimatedPropsMixin`.

```tsx
import { AnimateProps } from 'react-layered-chart';

interface Props {
  interpolatableValue: string;
}

@AnimateProps
class ExampleComponent extends React.Component<Props, ...> {
  animatedProps = {
    interpolatableValue: 250
  };

  render() {
    console.log(this.state.animated_interpolatableValue);
  }
}
```

<hr/>

#### `NonReactRender`

A class decorator that defers the bulk of rendering work until the next [animation frame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame). Useful primarily for expensive rendering that cannot be represented in the virtual DOM, such as when rendering to a `<canvas>`. You must define a method named `nonReactRender` that does the actual work of rendering.

You can access a mixin version at `NonReactRenderMixin`.

```tsx
import { NonReactRender } from 'react-layered-chart';

@NonReactRender
class ExampleComponent extends React.Component<...> {
  render() {
    return <canvas ref='canvas'/>;
  }

  nonReactRender() {
    const canvas = this.refs.canvas;
    // Do the actual rendering work.
  }
}
```

<hr/>

#### `PixelRatioContext`

A class decorator to allow a class to receive a context value called `pixelRatio` that specifies the pixel density for this chart. See [`Stack`](#stack) for more on this value. This context value only exists when the class is inside a `Stack` or `ChartProvider`.

You can access a mixin version at `PixelRatioContextMixin`.

```tsx
import { PixelRatioContext, PixelRatioContextType } from 'react-layered-chart';

@PixelRatioContext
class ExampleComponent extends React.Component<...> {
  // For Typescript usage, you have to specify the type of the context field like so.
  context: PixelRatioContextType;

  render() {
    console.log(this.context.pixelRatio);
  }
}
```

#### `PixelRatioContextProvider`

A class decorator to allow a class to provide a context value called `pixelRatio` that specified the pixel density for this chart. See [`Stack`](#stack) for more on this value. Because `Stack` and `ChartProvider` already have this behavior, you do not generally need to use this decorator. The initial value to provide on the context is read out of a prop named `pixelRatio`. If you nest multiple classes with this decorator, children will receive the value from their most immediate ancestor that specifies a `pixelRatio` prop.

You can access a mixin version at `PixelRatioContextProviderMixin`.

```tsx
import { PixelRatioContextProvider } from 'react-layered-chart';

interface Props {
  pixelRatio?: number;
}

@PixelRatioContextProvider
class ExampleParentComponent extends React.Component<Props, ...> { ... }
```

### Functions

#### `createStaticDataLoader(data, yDomains)`

Create a loader appropriate to pass to `ChartProvider` that unconditionally returns the provided static data. Useful for making simple interactive charts that have static data.

#### `getBoundsForInstantaneousData(data, range, xValuePath)`

Efficiently computes which span of indices in `data` intersect `range`. Each item in `data` is assumed to have a single X value, the dot-separated path to which is given by `xValuePath`. `data` should be sorted by `xValuePath`, ascending.

**Note**: because this function is intended as a helper to make rendering more efficient, it includes items just beyond the ends of the range as well so halfway-visible data will still be rendered.

```tsx
const data = [
  {
    value: 10,
    metadata: { timestamp: 15 }
  },
  ...
]

getBoundsForInstantaneousData(data, { min: 0, max: 1000 }, 'metadata.timestamp');
// -> { firstIndex: 0, lastIndex: ... }
```

<hr/>

#### `getIndexBoundsForSpanData(data, range, minXValuePath, maxXValuePath)`

Efficiently computes which span of indices in `data` intersect `range`. Each item in `data` is assumed to have start and end X values, the dot-separated path to which is given by `minXValuePath` and `maxXValuePath` respectively. `data` should be sorted by `minXValuePath`, ascending.

**Note**: because this function is intended as a helper to make rendering more efficient, it includes items just beyond the ends of the range as well so halfway-visible data will still be rendered.

```tsx
const data = [
  {
    value: 10,
    timeRange: { from: 0, to: 47 }
  },
  ...
]

getIndexBoundsForSpanData(data, { min: 0, max: 1000 }, 'timeRange.from', 'timeRange.to');
// -> { firstIndex: 0, lastIndex: ... }
```

<hr/>

#### `enforceRangeBounds(range, bounds)`

Adjust `range` to fit within `bounds` if possible, without changing the length of `range`. If `range` is longer than `bounds`, the extent is maintained and `range` is adjusted to have the same center as `bounds`.

```tsx
enforceRangeBounds({ min: -10, max: 10 }, { min: 0, max: 100 });
// -> { min: 0, max: 20 }

enforceRangeBounds({ min: 0, max: 120 }, { min: 0, max: 100 });
// -> { min: -10, max: 110 }
```

<hr/>

#### `enforceRangeExtent(range, minExtent, maxExtent)`

Adjust `range` so its length (extent) is between `minExtent` and `maxExtent`. If adjusted, the new range will be centered on the same point as the input range.

```tsx
enforceRangeExtent({ min: 0, max: 100 }, 20, 80);
// -> { min: 10, max: 90 }

enforceRangeExtent({ min: 0, max: 100 }, 120, 200);
// -> { min: -10, max: 110 }
```

<hr/>

#### `extendRange(range, factor)`

Extends `range` on each end by `length of range * factor`.

```tsx
extendRange({ min: 0, max: 100 }, 0.1);
// -> { min: -10, max: 110 }
```

<hr/>

#### `roundRange(range)`

Rounds each endpoint of `range` to the nearest integer.

```tsx
roundRange({ min: 0.4, max: 1.7 });
// -> { min: 0, max: 2 }
```

<hr/>

#### `niceRange(range)`

Uses [d3-scale's `nice`](https://github.com/d3/d3-scale#continuous_nice) to round the endpoints of `range` to nicer values.

```tsx
niceRange({ min: 34, max: 1454 });
// -> { min: 0, max: 1600 }
```

<hr/>

#### `mergeRanges(ranges)`

Returns a range that covers all the provided ranges. Returns `null` if no ranges are given.

```tsx
mergeRanges([ { min: 0, max: 50 }, { min: -10, max: 35 } ]);
// -> { min: -10, max: 50 }

mergeRanges([]);
// -> null
```

<hr/>

#### `rangeContains(maybeLargerRange, maybeSmallerRange)`

Returns `true` if `maybeLargerRange` contains `maybeSmallerRange`, `false` otherwise.

```tsx
rangeContains({ min: 0, max: 100 }, { min: 0, max: 50 })
// -> true

rangeContains({ min: 0, max: 100 }, { min: -50, max: 10 })
// -> false
```

<hr/>

#### `panRange(range, delta)`

Shift both endpoints of the range over by the specified amount.

```tsx
panRange({ min: 0, max: 100 }, 10);
// -> { min: 10, max: 110 }
```

<hr/>

#### `zoomRange(range, factor, anchorBias?)`

Zoom the given range in/out by the specified factor. `factor > 1` zooms in, `factor < 1` zooms out. If provided, `anchorBias` should be a value on `[0, 1]` that specifies where the focus of the zoom is, where 0 means to hold the minimum value constant (therefore moving only the maximum value to perform the requested zoom) and 1 vice-versa.

```tsx
zoomRange({ min: 0, max: 100 }, 2);
// -> { min: 25, max: 75 }

zoomRange({ min: 0, max: 100 }, 2, 0);
// -> { min: 0, max: 50 }
```

<hr/>

#### `createSelectDataForHover(xValueIterator)`

Create a [selector](https://github.com/reactjs/reselect) that will select the currently-hovered data point according to the scheme specified by `xValueIterator`. `xValueIterator` is a function that takes `(seriesId, datum)` and returns whatever numerical value should be used to order this particular datum in the X dimension. The created selector, when invoked with a `ChartProviderState`, then returns the data point for each series immediately preceding the current hover location according to this scheme.

<hr/>

### Constants

- `DEFAULT_X_DOMAIN`
- `DEFAULT_Y_DOMAIN`
